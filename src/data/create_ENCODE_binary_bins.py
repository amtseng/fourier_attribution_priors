import h5py
import numpy as np
import pandas as pd
import tqdm
import click
import os

def import_peaks(peaks_bed):
    """
    Imports a peaks BED file in NarrowPeak format as a Pandas DataFrame.
    Arguments:
        `peaks_bed`: a BED file (gzipped or not) containing peaks in ENCODE
            NarrowPeak format
    Returns a Pandas DataFrame.
    """
    return pd.read_csv(
        peaks_bed, sep="\t", header=None,  # Infer compression
        names=[
            "chrom", "peak_start", "peak_end", "name", "score", "strand",
            "signal", "pval", "qval", "summit_offset"
        ]
    )


def reformat_and_summarize_bin_labels_hdf5(src_labels_hdf5, dest_labels_hdf5):
    """
    From an HDF5 of labels generated by `generate_ENCODE_..._binary_labels.sh`,
    converts the HDF5 to a cleaner form. In the process, generates a NumPy array
    containing positive or negative labels for each bin.
    Arguments:
        `src_labels_hdf5`: path to an HDF5 containing labels; the HDF5 must be a
            labels dataset created by `generate_ENCODE_..._binary_labels.sh`;
            each row must be: (index, values, end, start, chrom), where "values"
            is a T-array of values, for each task T, containing 0, 1, or nan
        `dest_labels_hdf5`: path to a new HDF5 to create; this new HDF5 will
            have 4 datasets: a "chrom" N-array of chromosomes, a "start" N-array
            of bin coordinate starts, an "end" N-array of bin coordinate ends,
            and a "values" N x T array of values for each task, where each value
            is a label for the bin and task (1 for positive, 0 for negative, and
            -1 for ambiguous)
    Returns an N x 2 object array, where the first column is the chromosome, and
    the second column is an integer representing whether that bin is labeled as
    an overall positive (1), negative (0), or ambiguous (-1, to be ignored).
    Note that the N rows in this array are exactly parallel to the N rows in the
    label HDF5s.
    """
    src_h5_reader = h5py.File(src_labels_hdf5, "r")
    src_data = src_h5_reader["data"]["table"]
    num_bins = src_data.shape[0]
    num_tasks = len(src_data[0][1])

    # Create destination HDF5 datasets
    dest_h5_reader = h5py.File(dest_labels_hdf5, "w")
    chrom_dset = dest_h5_reader.create_dataset(
        "chrom", (num_bins,), dtype=h5py.string_dtype(encoding="ascii")
    )
    start_dset = dest_h5_reader.create_dataset("start", (num_bins,), dtype=int)
    end_dset = dest_h5_reader.create_dataset("end", (num_bins,), dtype=int)
    values_dset = dest_h5_reader.create_dataset("values", (num_bins, num_tasks))
   
    # Allocate bin-level labels, containing all chromosomes and bin-level labels
    bin_labels = np.empty((num_bins, 2), dtype=object)
    bin_labels[:, 1] = -1  # Default to ambiguous (-1)

    print("Cleaning up labels HDF5...")
    chunk_size = 20000
    num_chunks = int(np.ceil(num_bins / chunk_size))
    for i in tqdm.trange(num_chunks):
        chunk_slice = slice(i * chunk_size, (i + 1) * chunk_size)
        chunk = src_data[chunk_slice]

        chroms = np.array([row[4] for row in chunk]).astype(str)
        starts = np.array([row[3] for row in chunk])
        ends = np.array([row[2] for row in chunk])
        vals = np.array([row[1] for row in chunk])

        # Set the HDF5 data
        chrom_dset[chunk_slice] = chroms
        start_dset[chunk_slice] = starts
        end_dset[chunk_slice] = ends
        values_dset[chunk_slice] = np.nan_to_num(vals, nan=-1)

        # Set the chromosome in bin-level labels and compute the label values
        bin_labels[chunk_slice, 0] = chroms
        # Mask for where a row is positive or negative
        pos_mask = np.any(vals == 1, axis=1)
        neg_mask = np.all(vals == 0, axis=1)
        bin_labels[chunk_slice, 1][pos_mask] = 1
        bin_labels[chunk_slice, 1][neg_mask] = 0
        # -1 wherever did not pass mask

    src_h5_reader.close()
    dest_h5_reader.close()

    return bin_labels


def extract_bin_qvals(
    labels_hdf5, label_sources_hdf5, bin_labels_array, labelgen_tasks_tsv,
    check_coords=True
):
    """
    From an HDF5 of peak sources generated by
    `generate_ENCODE_..._binary_labels.sh`, extracts the q-values stored for
    each bin/task to a NumPy array.
    Arguments:
        `labels_hdf5`: path to an HDF5 containing labels; the HDF5 must be a
            labels dataset created by `generate_ENCODE_..._binary_labels.sh`;
            each row must be: (index, values, end, start, chrom), where "values"
            is a T-array of values, for each task T, containing 0, 1, or nan
        `label_sources_hdf5`: path to an HDF5 containing source peaks; the HDF5
            must be a dataset created by `generate_ENCODE_..._binary_labels.sh`;
            each row must be:
            (index, peak_chroms, peak_ints, end, start, chrom), where
            "peak_chroms" is a list of T chromosomes, for each task, and
            "peak_ints" is a list of 2T interval endpoints for the peaks (end
            before start)
        `bin_labels_array`: array of bin chromosomes and labels, as generated
            by `reformat_and_summarize_bin_labels_hdf5`
        `labelgen_tasks_tsv`: path to tasks TSV fed into
            `generate_ENCODE_..._binary_labels.sh` to generate the HDF5s
        `check_coords`: if True, asserts that the bin coordinates in
            `label_sources_hdf5` match up exactly to the positive bin
            coordinates in `labels_hdf5`
    Returns an N x T x 2 array of q-values and peak ranks for each bin and task.
    That is, for each bin/task, this array records the q-value of the underlying
    peak, and the rank of the peak by q-value (rank of 1 is highest -log(q)). If
    a bin does not have an underlying peak, the q-value and peak rank will both
    be 0. Note that the N rows in this array are exactly parallel to the N rows
    in `labels_hdf5`.
    """
    labels_h5_reader = h5py.File(labels_hdf5, "r")
    labels_data = labels_h5_reader["data"]["table"]
    num_bins = labels_data.shape[0]
    num_tasks = len(labels_data[0][1])

    sources_h5_reader = h5py.File(label_sources_hdf5, "r")
    sources_data = sources_h5_reader["data"]["table"]

    # Get set of positives; should match size of source dataset exactly
    pos_mask = bin_labels_array[:, 1] == 1
    num_pos = np.sum(pos_mask)
    assert sources_data.shape[0] == num_pos

    if check_coords:
        # Check that all the source coordinates are in order
        print("Checking source coordinates...")
        pos_inds = np.where(pos_mask)[0]
        for i in tqdm.trange(num_pos):
            pos_index = pos_inds[i]
            source_row, label_row = sources_data[i], labels_data[pos_index]
            assert source_row[3] == label_row[2]
   
    # Allocate array for q-values and ranks
    qvals_ranks = np.zeros((num_bins, num_tasks, 2))  # Defaults to 0, 0
    peak_qvals_ranks = np.zeros((num_pos, num_tasks, 2))  # Just for the peaks

    # Import the peak BEDs, in the same order as the tasks in label generation
    # Also add a column for rank
    peaks_tables = []
    with open(labelgen_tasks_tsv, "r") as f:
        next(f)  # Header
        for line in f:
            peaks_bed = line.strip().split("\t")[1]
            peaks_table = import_peaks(peaks_bed)
            # Drop duplicate peaks, keeping the one with the best q-value
            peaks_table = peaks_table.sort_values("qval", ascending=False)
            peaks_table = peaks_table.drop_duplicates(
                subset=["chrom", "peak_start", "peak_end"],
                keep="first"
            )
            # Set ranks column
            peaks_table["rank"] = peaks_table["qval"].rank(
                method="first", ascending=False
            )
            peaks_tables.append(peaks_table)
    
    # Read the source peaks into an P x T x 3 array
    source_coords = np.empty((num_pos, num_tasks, 3), dtype=object)
    chunk_size = 20000
    num_chunks = int(np.ceil(num_pos / chunk_size))
    print("Reading source peaks coordinates...")
    for i in tqdm.trange(num_chunks):
        chunk_slice = slice(i * chunk_size, (i + 1) * chunk_size)
        chunk = sources_data[chunk_slice]

        chroms = np.array([row[1] for row in chunk]).astype(str)
        ints = np.nan_to_num(
            np.array([row[2] for row in chunk]), nan=-1
        ).astype(int)  # -1 wherever no peak
        # Turn intervals into B x T x 2, and put start first
        ints = np.flip(np.reshape(ints, (-1, num_tasks, 2)), axis=2)

        source_coords[chunk_slice, :, 0] = chroms
        source_coords[chunk_slice, :, 1:] = ints

    # For each task, create a table from the coordinates, and join it with the
    # corresponding peak BED
    for i in range(num_tasks):
        print("Joining source peaks with peaks BED... (task %d)" % (i + 1))
        source_coords_table = pd.DataFrame(
            data=source_coords[:, i],
            columns=["chrom", "peak_start", "peak_end"]
        )
        merged = source_coords_table.merge(
            peaks_tables[i], on=["chrom", "peak_start", "peak_end"], how="left"
        )
        qval_ranks = merged[["qval", "rank"]].values
        # Fill in the q-values and ranks, turning anything unmatched into 0;
        # this is because some coordinates in the source table won't have a
        # match, as they are coordinates for another task)
        peak_qvals_ranks[:, i] = np.nan_to_num(qval_ranks, nan=0)

    labels_h5_reader.close()
    sources_h5_reader.close()

    # For the bins with peak locations, set the q-values and ranks
    print("Setting q-values and ranks...")
    qvals_ranks[pos_mask] = peak_qvals_ranks

    return qvals_ranks


@click.command()
@click.option(
    "--cell-line-or-tf", "-t", required=True,
    help="Name of cell line (for DNase-seq) or TF (for TF-ChIPseq)"
)
@click.option(
    "--assay", "-a", required=True, type=click.Choice(["DNase", "TFChIP"]),
    help="Type of assay, either DNase or TFChIP"
)
@click.option(
    "--labelgen-tasks-tsv", "-g", default=None,
    help="Path to tasks TSV used by generate_ENCODE_TFChIP_binary_labels.sh or generate_ENCODE_DNase_binary_labels.sh; defaults to /users/amtseng/att_priors/data/interim/ENCODE_{assay}/binary/{cell_line_or_tf}/{cell_line_or_tf}_labelgen_tasks.tsv"
)
@click.option(
    "--labels-hdf5", "-l", default=None,
    help="Path to labels HDF5, generated by generate_ENCODE_TFChIP_binary_labels.sh or generate_ENCODE_DNase_binary_labels.sh; defaults to /users/amtseng/att_priors/data/interim/ENCODE_{assay}/binary/{cell_line_or_tf}/{cell_line_or_tf}_genomewide_labels.h5"
)
@click.option(
    "--label-sources-hdf5", "-s", default=None,
    help="Path to source labels HDF5, generated by generate_ENCODE_TFChIP_binary_labels.sh or generate_ENCODE_DNase_binary_labels.sh; defaults to /users/amtseng/att_priors/data/interim/ENCODE_{assay}/binary/{cell_line_or_tf}/label_source.{cell_line_or_tf}_genomewide_labels.h5"
)
@click.option(
    "--out-labels-hdf5", "-o", default=None,
    help="Path to output the sanitized version of the labels HDF5; defaults to /users/amtseng/att_priors/data/processed/ENCODE_{assay}/binary/labels/{cell_line_or_tf}/{cell_line_or_tf}_labels.h5"
)
@click.option(
    "--bin-labels-npy", "-b", default=None,
    help="Output path for bin labels NumPy array; defaults to /users/amtseng/att_priors/data/processed/ENCODE_{assay}/binary/labels/{cell_line_or_tf}/{cell_line_or_tf}_bin_labels.npy"
)
@click.option(
    "--peak-qvals-npy", "-q", default=None,
    help="Output path for bin-level q-value NumPy array; defaults to /users/amtseng/att_priors/data/processed/ENCODE_{assay}/binary/labels/{cell_line_or_tf}/{cell_line_or_tf}_peak_qvals.npy"
)
@click.option(
    "--skip-check-coords", is_flag=True,
    help="If specified, do not check that the bin coordinates in the label sources match up with the positive bin coordinates in the labels"
)
def main(
    cell_line_or_tf, assay, labelgen_tasks_tsv, labels_hdf5, label_sources_hdf5,
    out_labels_hdf5, bin_labels_npy, peak_qvals_npy, skip_check_coords
):
    """
    From the outputs from `generate_ENCODE_..._binary_labels.sh`, converts it
    to a training-ready form. This script does the following:
    1. Reformats the binary labels to a nicer output, with coordinates and
        labels in separate datasets (and converts NaNs to -1)
    2. Extracts the chromosomes and bin-level labels to a NumPy array, for easy
        of identification of positive bins at training time
    3. Matches the underlying source peaks in each bin to the q-value from the
        original peaks BED files, noting the q-value and rank of peak confidence
        for each task in each bin
    """
    interim_base = os.path.join(
        "/users/amtseng/att_priors/data/interim/",
        "ENCODE_%s/binary/%s" % (assay, cell_line_or_tf)
    )
    processed_base = os.path.join(
        "/users/amtseng/att_priors/data/processed/",
        "ENCODE_%s/binary/labels/%s" % (assay, cell_line_or_tf)
    )
    if not labelgen_tasks_tsv:
        labelgen_tasks_tsv = os.path.join(
            interim_base, "%s_labelgen_tasks.tsv" % cell_line_or_tf
        )
    if not labels_hdf5:
        labels_hdf5 = os.path.join(
            interim_base, "%s_genomewide_labels.h5" % cell_line_or_tf
        )
    if not label_sources_hdf5:
        label_sources_hdf5 = os.path.join(
            interim_base,
            "label_source.%s_genomewide_labels.h5" % cell_line_or_tf
        )
    if not out_labels_hdf5:
        out_labels_hdf5 = os.path.join(
            processed_base, "%s_labels.h5" % cell_line_or_tf
        )
    if not bin_labels_npy:
        bin_labels_npy = os.path.join(
            processed_base, "%s_bin_labels.npy" % cell_line_or_tf
        )
    if not peak_qvals_npy:
        peak_qvals_npy = os.path.join(
            processed_base, "%s_peak_qvals.npy" % cell_line_or_tf
        )
    
    os.makedirs(os.path.dirname(out_labels_hdf5), exist_ok=True)
    os.makedirs(os.path.dirname(bin_labels_npy), exist_ok=True)
    os.makedirs(os.path.dirname(peak_qvals_npy), exist_ok=True)

    # Reformat the labels HDF5 and create/save the bin labels
    bin_labels_array = reformat_and_summarize_bin_labels_hdf5(
        labels_hdf5, out_labels_hdf5
    )
    np.save(bin_labels_npy, bin_labels_array, allow_pickle=True)

    # Create/save the peak q-values
    peak_qvals_array = extract_bin_qvals(
        labels_hdf5, label_sources_hdf5, bin_labels_array, labelgen_tasks_tsv,
        check_coords=(not skip_check_coords)
    )
    np.save(peak_qvals_npy, peak_qvals_array)

if __name__ == "__main__":
    main()
